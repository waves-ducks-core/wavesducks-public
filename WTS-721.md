# \[Proposal\] Waves Token Standard 721 

This proposal defines minimalistic standard for non-fungible tokens in the Waves ecosystem. 
The main goal of the standard is to provide a unified way to get NFT image and metadata.
Keeping in mind different ways of NFT minting in Waves (using a dApp or directly with an `Issue` transaction) this proposal covers both cases.

## Collections

Every NFT should belong to a collection, by default a smart contract address minting an NFT is a collection ID. Collection name should be defined
in the account state with a key `WTS_721_name` and string value so a request to the URL `http://nodes.wavesnodes.com/addresses/data/{{COLLECTION_ID}}/WTS_721_name` should always return collection name. Collection name can be changed at any moment with a `Data` transaction or using smart contract method called `func setName(name: String)`.

## Sequence numbers

Optionally collection items can have numbers and issuers' account state should track NFT numbers. It should be possible to get a number of a particular NFT by ID
in the collection or NFT ID by number using one request to the contract state. To make it possible account state should hold 2 keys for every minted NFT with following key templates:
- `WTS_721_id_{{NFT_ID}}_number` with an integer value of a number of an NFT with asset id (`NFT_ID`) in the collection
- `WTS_721_number_{{NFT_NUMBER}}_id` with a string value of asset id corresponding to the NFT with number `NFT_NUMBER`

These two types of keys let users knowing asset id to fetch a sequential number by making a request like
`http://nodes.wavesnodes.com/addresses/data/{{COLLECTION_ID}}/WTS_721_id_{{NFT_ID}}_number`.
For users knowing only a sequential number (or looking for an NFT with a particular number) it simplifies searches so they have to make only one request like 
`http://nodes.wavesnodes.com/addresses/data/{{COLLECTION_ID}}/WTS_721_number_{{NFT_NUMBER}}_id`.


## Data

For every NFT in the collection there should be a unique URL holding NFT basic details and metadata. 
The URL can be on a centralized server, IPFS or a URL to the state key. 
Issuer address state (collection address) should have a key `WTS_721_tokenURITemplate` key with a string value, 
which sets a template of how to construct a URL to get NFT details. The template should have a placeholder `{{NFT_ID}}` which should be replaced with a 
real asset id to get final URL. For example, the state key of a collection can look like below

```javascript
{
  "key": "WTS_721_tokenURITemplate",
  "type": "string",
  "value": "https://example.com/{{NFT_ID}}"
}
```

Knowing collection ID (contract address) and NFT ID (asset id) clients should be able to make 2 requests to get all data about the NFT. 

1. Quering `http://nodes.wavesnodes.com/addresses/data/{{COLLECTION_ID}}/WTS_721_tokenURITemplate` should return a template for a URL. 
2. Using the template and replacing `{{NFT_ID}}` with a real asset id clients should get a final URL with all details. 

Requests to fetch token details should always return a valid JSON with 2 possible values:

1. JSON object with details (see requirements below)
2. JSON object with Waves protocol node response for the [state key request](http://nodes.wavesnodes.com/api-docs/index.html#/addresses/getDataByKey) with following keys:
```javascript
{
  "key": "xxx",
  "type": "string",
  "value": "{}" // valid stringified JSON
}
```

> In the case of JSON object with Waves protocol node response the `value` key should be parsed by clients with standard functions like `JSON.parse()` to get the metadata object.

### NFT details response data structure
Either response from a centralized endpoint or `value` key in the blockchain state should contain following mandatory fields (other fields are allowed as well):

```javascript
{
  assetId: "C1iWsKGqLwjHUndiQ7iXpdmPum9PeCDFfyXBdJJosDRS",
  name: "Example",
  description: "Some description",
  image: "https://...",
  external_url: "https://...",
  background_color: "#cccccc", 
  object: {
    mime_type: "video/mp4",
    link: "https://..."
  },
  metadata: {}
}
```

- `assetId` should be the same as in the blockchain
- `name` is defined in the object should be used as the main one and takes precedence over the asset name in the blockchain
- `description` A human readable description of the item. Markdown is supported.
- `image` This is the URL to the image of the item. Can be just about any type of image (including SVGs), and can be IPFS URLs or paths. We recommend using a 350 x 350 image.
- `external_url` can be used by clients to give a direct link on the collection web site.
- `background_color` is background color of the item used to display in any types of clients. Must be a six-character hexadecimal without a pre-pended #.
- `object` contains a mime type of original object associated with NFT and a link to it
- `metadata` is a valid JSON object with any additional information.

This JSON structure is expansible and can hold any other keys like [OpenSea Metadata Structure](https://docs.opensea.io/docs/metadata-standards#metadata-structure) or [ERC721 Metadata Standard](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md)


## Smart Contract Template

Below you can find a simple smart contract interface for listed above functions/keys:

```scala
{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

func tryGetInteger(key: String) = {
  match getInteger(this, key) {
      case b:Int => b
      case _ => 0
  }
}

@Callable(i)
func setName(name: String) = {
  if i.caller != this then throw("Allowed only for the contract itself") else
  [
    StringEntry("WTS_721_name", name)
  ]
}

@Callable(i)
func setTokenURITemplate(template: String) = {
  if i.caller != this then throw("Allowed only for the contract itself") else
  if (template.contains("{{NFT_ID}}") == false) then throw("Template URI should have a placeholder {{NFT_ID}}") else 
  [
    StringEntry("WTS_721_tokenURITemplate", template)
  ]
}

@Callable(i)
func mint() = {
  let asset = Issue("Example NFT", "", 1, 0, false, unit, 0)
  let assetId = asset.calculateAssetId()
  let assetIdStr = assetId.toBase58String()
  let globalLastNumberKey = "global_static_last_number"
  let globalLastNumber = tryGetInteger(globalLastNumberKey)
  let newNumber = globalLastNumber + 1
  
  [
    IntegerEntry(globalLastNumberKey, newNumber),
    IntegerEntry("WTS_721_id_" + assetIdStr + "_number", newNumber),
    StringEntry("WTS_721_number_" + newNumber.toString() + "_id", assetIdStr),
    asset,
    ScriptTransfer(i.caller, 1, assetId)
  ]
}        
```
