{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

func tryGetString(key: String) = {
    match getString(this, key) {
        case a:String => a
        case _ => ""
    }
}

func tryGetStringExternal(address: Address, key: String) = {
    match getString(address, key) {
        case a:String => a
        case _ => ""
    }
}

func getOracle() = Address(tryGetString("static_oracleAddress").fromBase58String())

func getBreederAddress() =  Address(tryGetStringExternal(getOracle(),"static_breederAddress").fromBase58String()) #base58'3PDVuU45H7Eh5dmtNbnRNRStGwULA7NY6Hb'

func getIncubatorAddress() =  Address(tryGetStringExternal(getOracle(),"static_incubatorAddress").fromBase58String()) #base58'3PEktVux2RhchSN63DsDo4b4mz4QqzKSeDv'
func getSwopPromoAddress() =  Address(tryGetStringExternal(getOracle(),"static_swopPromoAddress").fromBase58String()) #base58'3P6s9C39Ak5FAQ3F5VapYJ3ULxgbsAReXWD'
func getEggAssetId() = tryGetStringExternal(getOracle(),"static_eggAssetId").fromBase58String() #base58'C1iWsKGqLwjHUndiQ7iXpdmPum9PeCDFfyXBdJJosDRS'
func getWearablesAddress() = Address(tryGetStringExternal(getOracle(),"static_wearablesAddress").fromBase58String())
func getFarmingAddress() =  Address(tryGetStringExternal(getOracle(),"static_farmingAddress").fromBase58String())
func getCouponsAddress() = Address(tryGetStringExternal(getOracle(),"static_couponsAddress").fromBase58String()) 
func getRebirthAddress() =  Address(tryGetStringExternal(getOracle(),"static_rebirthAddress").fromBase58String())


let MANTLENAME = "mantle"

let salesEnabled = false

let STATUSFREE = "FREE"
let STATUSOCCUPIED = "OCCUPIED"

func keyDuckLock(callerAddress: String, duckId: String) = {
  "address_" + callerAddress + "_duck_" + duckId + "_status"
}

func keyInvestor(callerAddress: String) = {
  "address_" + callerAddress + "_amount"
}


func keyArtefactInvested(type: String, artefactId: String) = {
  "artefact_" + type + "_artefactId_" + artefactId + "_invested"
}

func keyOnlyArtefactLevel(artefactId: ByteVector) = {
  "artefactId_" + artefactId.toBase58String() + "_level"
}

func keyArtefactIdByDuckAndType(type: String, duckId: ByteVector) = {
  "artefact_ " + type + "_duck_" + duckId.toBase58String() + "_artefactId"
}

func keyArtefactOwner(type: String, artefactId: ByteVector) = {
  "artefact_ " + type + "_artefactId_" + artefactId.toBase58String() + "_owner"
}

func keyArtefactOwnerAndStatus(type: String, owner: String, artefactId: ByteVector) = {
  "address_" + owner + "_artefact_" + type + "_artefactId_" + artefactId.toBase58String() + "_status"
}

func keyArtefactStatus(type: String, artefactId: ByteVector) = {
  "artefact_ " + type + "_artefactId_" + artefactId.toBase58String() + "_status"
}

func keyArtefactType(artefactId: ByteVector) = {
  "artefactId_" + artefactId.toBase58String() + "_type"
}

func keyArtefactLevel(type: String, owner: String, artefactId: ByteVector) = {
  "address_" + owner + "_artefact_" + type + "_artefactId_" + artefactId.toBase58String() + "_level"
}

func keyPutOnArtefact(type: String, owner: String, duckId: String, artefactId: ByteVector) = {
  "address_" + owner + "_duck_" + duckId + "_artefact_" + type + "_artefactId_" + artefactId.toBase58String() + "_status"
}

func keyArtefactExists(type: String, artefactId: ByteVector) = {
  "artefact_" + type + "_artefactId_" + artefactId.toBase58String()
}

func keyArtefactNftId(artefactId: ByteVector)={
  "artefactId_" + artefactId.toBase58String()+"_nft"
}

func isJackpot(assetId: ByteVector ) = assetInfo(assetId).value().name.value().takeRight(1) == "U"

func asInt(value: Any) = match value {
  case int: Int => int
  case _ => throw("WAI: wrong type, expected: Int")
}


# func upgradeMantleFunc(i: Invocation, artefactId: String, amount: Int) = {
#     let kMantleExists = keyArtefactExists(MANTLENAME, artefactId.fromBase58String())
#     let kMantleOwner = keyArtefactOwner(MANTLENAME, artefactId.fromBase58String())

#     let mantleExists = getBooleanValue(kMantleExists)
#     let mantleOwner = getStringValue(kMantleOwner)
#     if (!mantleExists) then throw("WUPM: Mantle with such an ID does not exist") else
#     if (mantleOwner != i.originCaller.toString()) then throw("WUPM: You're not an owner of the mantle")
#     else {

#       let kMantleInvested = keyArtefactInvested(MANTLENAME, artefactId)
#       let mantleAlreadyInvested = getIntegerValue(kMantleInvested)

#       let kMantleLevel = keyArtefactLevel(MANTLENAME, i.originCaller.toString(), artefactId.fromBase58String())
#       let kOnlyArtefactLevel = keyOnlyArtefactLevel(artefactId.fromBase58String())

#       let totalInvested = mantleAlreadyInvested + amount
#       let newLevel = (10 * pow(totalInvested, 8, 6, 1, 8, HALFUP) + 100000000) / 100000000
#       [
#         IntegerEntry(kMantleLevel, newLevel),
#         IntegerEntry(kMantleInvested, totalInvested),
#         IntegerEntry(kOnlyArtefactLevel, newLevel)
#       ]
#     }
# }

@Callable(i)
func configureOracle(oracle: String) = {
  if i.caller != this then throw("WCO: admin only") else 
  [
    StringEntry("static_oracleAddress",oracle)
  ]

}

# @Callable(i)
# func issueFreeMantle(address: String, type: String, level: Int) = {
#   if !salesEnabled then throw("DIFM: Currentmy disabled") else 
#   if (i.caller != this && i.caller != getSwopPromoAddress()) then throw("WIFM: Can be called only by admin") else
#   if (type != MANTLENAME) then throw("WIFM: You can buy only mantles now")
#   else {

#       let issueMantleNFT = Issue("DUCK-MANTLE-0", "[Artefact] Mantle NFT for Jeduck", 1, 0, false)
#       let mantleNftId = issueMantleNFT.calculateAssetId()

#       let kMantleLevel = keyArtefactLevel(MANTLENAME, address, mantleNftId)
#       let kMantleExists = keyArtefactExists(MANTLENAME, mantleNftId)
#       let kMantleOwner = keyArtefactOwner(MANTLENAME, mantleNftId)
#       let kMantleStatus = keyArtefactStatus(MANTLENAME, mantleNftId)
#       let kArtefactType = keyArtefactType(mantleNftId)
#       let kMantleInvested = keyArtefactInvested(MANTLENAME, mantleNftId.toBase58String())
#       let kArtefactOwnerAndStatus = keyArtefactOwnerAndStatus(MANTLENAME, address, mantleNftId)
#       let kOnlyArtefactLevel = keyOnlyArtefactLevel(mantleNftId)
#       #let newLevel = (10 * pow(totalInvested, 8, 6, 1, 8, HALFUP) + 100000000) / 100000000
#       #let part1 =(level*100000000-100000000)/10
#       #let invested = log(part1, 8, 6, 1, 8, HALFUP)
#       let invested = pow(level - 1, 1, (1000000000/6), 8, 8, HALFUP)
#       ([
#         IntegerEntry(kMantleLevel, level),
#         IntegerEntry(kMantleInvested, invested),
#         BooleanEntry(kMantleExists, true),
#         StringEntry(kMantleOwner, address),
#         StringEntry(kMantleStatus, STATUSFREE),
#         StringEntry(kArtefactType, MANTLENAME),
#         StringEntry(kArtefactOwnerAndStatus, STATUSFREE),
#         IntegerEntry(kOnlyArtefactLevel, level)
#       ],mantleNftId.toBase58String())
#   }
# }

# @Callable(i)
# func buyArtefact(type: String) = {
#   if !salesEnabled then throw("DIFM: Currentmy disabled") else 
#   if (type != MANTLENAME) then throw("WBA: You can buy only mantles now") 
#   else {
#     let MANTLEPRICE = 1_000_000
#     strict amountPaidByCoupons = invoke(getCouponsAddress(),"useCoupons",[MANTLEPRICE],[]).asInt()
#     let leftToPay = MANTLEPRICE-amountPaidByCoupons
#     strict payment = if leftToPay!=0 then {
#       let firstPayment = i.payments[0].value()
#       if (firstPayment.assetId != getEggAssetId()) then throw("WBA: You can attach only EGG tokens with the following asset id: " + getEggAssetId().toBase58String()) else 
#       if (firstPayment.amount != leftToPay) then throw("WBA: To buy a mantle you currently need the following amount of EGGlets: " + leftToPay.toString()) else
#       leftToPay
#     }else 0
    

#       let issueMantleNFT = Issue("DUCK-MANTLE-0", "[Artefact] Mantle NFT for Jeduck", 1, 0, false)
#       let mantleNftId = issueMantleNFT.calculateAssetId()

#       let kMantleLevel = keyArtefactLevel(MANTLENAME, i.caller.toString(), mantleNftId)
#       let kMantleExists = keyArtefactExists(MANTLENAME, mantleNftId)
#       let kMantleOwner = keyArtefactOwner(MANTLENAME, mantleNftId)
#       let kMantleStatus = keyArtefactStatus(MANTLENAME, mantleNftId)
#       let kArtefactType = keyArtefactType(mantleNftId)
#       let kMantleInvested = keyArtefactInvested(MANTLENAME, mantleNftId.toBase58String())
#       let kArtefactOwnerAndStatus = keyArtefactOwnerAndStatus(MANTLENAME, i.caller.toString(), mantleNftId)
#       let kOnlyArtefactLevel = keyOnlyArtefactLevel(mantleNftId)

#       [
#         IntegerEntry(kMantleLevel, 1),
#         IntegerEntry(kMantleInvested, MANTLEPRICE),
#         BooleanEntry(kMantleExists, true),
#         StringEntry(kMantleOwner, i.caller.toString()),
#         StringEntry(kMantleStatus, STATUSFREE),
#         StringEntry(kArtefactType, MANTLENAME),
#         StringEntry(kArtefactOwnerAndStatus, STATUSFREE),
#         IntegerEntry(kOnlyArtefactLevel, 1)
#       ]
    
#   } 
# }

#@Callable(i)
#func upgradeMantle(artefactId: String) = {
#  if !salesEnabled then throw("DIFM: Currentmy disabled") else 
#  let upgradePointPrice = 1_000_000
#  let firstPayment = i.payments[0].value()
#  let amount = firstPayment.amount
#  if (firstPayment.assetId != getEggAssetId()) then throw("WUM: You can attach only EGG tokens with the following asset id: " + getEggAssetId().toBase58String())
#  else if (firstPayment.amount < upgradePointPrice) then throw("WUM: Minimal payment for upgrading mantle is: " + upgradePointPrice.toString())
#  else {
#      upgradeMantleFunc(i,artefactId,amount)
#  }
#}

# @Callable(i)
# func upgradeMantleByCoupons(artefactId: String, couponsAmount: Int) = {
#   if !salesEnabled then throw("DIFM: Currentmy disabled") else 
#   let upgradePointPrice = 1_000_000
#   let firstPayment = i.payments[0].value()
#   if (couponsAmount < upgradePointPrice) then throw("WUMBC: Minimal payment for upgrading mantle is: " + upgradePointPrice.toString())
#   else {
#       strict amountPaidByCoupons = invoke(getCouponsAddress(),"useCoupons",[couponsAmount],[]).asInt()
#       if couponsAmount != amountPaidByCoupons then throw("WUMBC: Not enough coupons! Please make sure to pick lower coupon amount!") else

#       upgradeMantleFunc(i,artefactId,couponsAmount)
#   }
# }


#TODO: check if duck wears sweater, if so stake the duck automatically

@Callable(i)
func putOnArtefact(artefactId: String) = {
  let firstPayment = i.payments[0].value()
  let secondPayment = i.payments[1].value()
  let attachedAssetInfo = assetInfo(firstPayment.assetId.value()).value()
  let secondAttachedAssetInfo = assetInfo(secondPayment.assetId.value()).value()
  if (firstPayment.amount != 1) then throw("WPOA: DUCK NFT is not attached") else
  if (secondPayment.amount != 1) then throw("WPOA: MANTLE NFT is not attached") else
  if (attachedAssetInfo.issuer != getIncubatorAddress() && attachedAssetInfo.issuer != getBreederAddress()) then throw("WPOA: You can attach only DUCKs issued by incubator or breeder ") else
  if (secondAttachedAssetInfo.issuer != this) then throw("WPOA: You can attach only mantles issues by this sc.")
  else {
    let linkedNftId = getStringValue(keyArtefactNftId(artefactId.fromBase58String()))
    let nftId = value(secondPayment.assetId)
    if linkedNftId != nftId.toBase58String() then throw("Mismatch between artefactId and nftId") else 
      let hasSweater = tryGetStringExternal(getWearablesAddress(),firstPayment.assetId.value().toBase58String()+"_ART-XSWEATER")
      let kMantleExists = keyArtefactExists(MANTLENAME, artefactId.fromBase58String())
      let kMantleStatus = keyArtefactStatus(MANTLENAME, artefactId.fromBase58String())
      let kArtefactOwnerAndStatus = keyArtefactOwnerAndStatus(MANTLENAME, i.originCaller.toString(), artefactId.fromBase58String())
      let kDuckLock = keyDuckLock(i.originCaller.toString(), firstPayment.assetId.value().toBase58String())
      let mantleExists = getBooleanValue(kMantleExists)
      let mantleStatus = getStringValue(kMantleStatus)

      let kArtefactIdByType = keyArtefactIdByDuckAndType(MANTLENAME, firstPayment.assetId.value())

      if (!mantleExists) then throw("WPOA: Mantle with such an ID does not exist") else
      if (mantleStatus != STATUSFREE) then throw("WPOA: Mantle is already used!")
      else {
        strict stakeDuck = if hasSweater != "" then 
                              if isJackpot(firstPayment.assetId.value()) then invoke(getFarmingAddress(),"stakeNFTWithoutPerch",[],i.payments) else invoke(getFarmingAddress(),"stakeNFT",[],i.payments)
                            else []

        let kPutOnArtefact = keyPutOnArtefact(MANTLENAME, i.originCaller.toString(), firstPayment.assetId.value().toBase58String(), artefactId.fromBase58String())
        let kMantleOwner = keyArtefactOwner(MANTLENAME, artefactId.fromBase58String())
        [
          BooleanEntry(kPutOnArtefact, true),
          StringEntry(kMantleStatus, STATUSOCCUPIED),
          StringEntry(kArtefactOwnerAndStatus, STATUSOCCUPIED),
          StringEntry(kMantleOwner,i.originCaller.toString()),
          BooleanEntry(kDuckLock, true),
          StringEntry(kArtefactIdByType, artefactId)
        ]
      }
  }
}

#TODO: check if duck wears sweater, if so unstake the duck automatically
@Callable(i)
func takeOffArtefact(duckId:String, artefactType: String) = {
  
  let kArtefactIdByTypeAndDuck = keyArtefactIdByDuckAndType(artefactType, duckId.fromBase58String())
  let artefactId = getStringValue(kArtefactIdByTypeAndDuck)
  
  let kArtefactType = keyArtefactType(artefactId.fromBase58String())
  let kPutOnArtefact = keyPutOnArtefact(artefactType, i.originCaller.toString(), duckId, artefactId.fromBase58String())
  let kPutOnArtefactStatus = getBooleanValue(kPutOnArtefact)
  let kArtefactOwnerAndStatus = keyArtefactOwnerAndStatus(artefactType, i.originCaller.toString(), artefactId.fromBase58String())
  let kDuckLock = keyDuckLock(i.originCaller.toString(), duckId)
  let linkedNftId = getStringValue(keyArtefactNftId(artefactId.fromBase58String()))

  let kMantleStatus = keyArtefactStatus(artefactType, artefactId.fromBase58String())
  if (kPutOnArtefactStatus != true) then throw("WTOA: There is no duck with such parameteres")
  else {
    let hasSweater = tryGetStringExternal(getWearablesAddress(),duckId+"_ART-XSWEATER")
    let kMantleOwner = keyArtefactOwner(artefactType, artefactId.fromBase58String())
    let isStaked = if tryGetStringExternal(getFarmingAddress(),"address_"+i.originCaller.toString()+"_asset_"+duckId+"_unstaker") == "" then false else true
    strict unstakeDuck = if hasSweater != "" && isStaked then
                            if isJackpot(duckId.fromBase58String()) then invoke(getFarmingAddress(),"unstakeJackpot",[duckId],[]).asInt() else invoke(getFarmingAddress(),"unstakeNFT",[duckId],[]).asInt()
                         else 0
    let sendRewards = if unstakeDuck > 0 then [ScriptTransfer(i.originCaller, unstakeDuck, getEggAssetId())] else []
    [
      DeleteEntry(kPutOnArtefact),
      DeleteEntry(kArtefactIdByTypeAndDuck),
      DeleteEntry(kDuckLock),
      StringEntry(kMantleStatus, STATUSFREE),
      DeleteEntry(kArtefactOwnerAndStatus),
      DeleteEntry(kMantleOwner),
      ScriptTransfer(i.originCaller, 1, duckId.fromBase58String()),
      ScriptTransfer(i.originCaller, 1, linkedNftId.fromBase58String())
    ]++sendRewards
  }
}

@Callable(i)
func exportMantles(ids: String)={
  let nftIds = ids.split(";")
  func handleId(acc: List[StringEntry|ScriptTransfer|DeleteEntry], id: String) = {
    let kMantleOwner = keyArtefactOwner(MANTLENAME, id.fromBase58String())
    let mantleOwner = valueOrErrorMessage(tryGetString(kMantleOwner), kMantleOwner)
    let kArtefactOwnerAndStatus = keyArtefactOwnerAndStatus(MANTLENAME, mantleOwner, id.fromBase58String())
    let kMantleStatus = keyArtefactStatus(MANTLENAME, id.fromBase58String())
    let mantleStatus = valueOrErrorMessage(getString(kMantleStatus), kMantleStatus)
    let linkedNftId = getStringValue(keyArtefactNftId(id.fromBase58String()))

    if (mantleOwner != "" && mantleStatus == STATUSFREE && Address(mantleOwner.fromBase58String()) != this ) then
      acc ++ [
        ScriptTransfer(Address(mantleOwner.fromBase58String()), 1, linkedNftId.fromBase58String()),
        DeleteEntry(kMantleOwner),
        DeleteEntry(kArtefactOwnerAndStatus)
        
      ]
    else
      acc
  }

  FOLD<20>(nftIds, [], handleId)
}

        
@Callable(i)
func issueNftForMantles(ids: String)={
  let nftIds = ids.split(";")
  func handleId(acc: List[ScriptTransfer|StringEntry], id: String) = {
    let kMantleOwner = keyArtefactOwner(MANTLENAME, id.fromBase58String())
    let kArtefactNftId = keyArtefactNftId(id.fromBase58String())
    let mantleOwner = valueOrErrorMessage(tryGetString(kMantleOwner), kMantleOwner+" "+id+" "+MANTLENAME)
    if mantleOwner == "" || tryGetString(kArtefactNftId) != "" then acc++[] else 
      let issueMantleNFT = Issue("DUCK-MANTLE-0", "[Artefact] Mantle NFT for Jeduck", 1, 0, false, unit, size(acc))
      let mantleNftId = issueMantleNFT.calculateAssetId()
      acc ++ [
        issueMantleNFT,
        StringEntry(kArtefactNftId,mantleNftId.toBase58String())
      ]
  }

  FOLD<20>(nftIds, [], handleId)
}