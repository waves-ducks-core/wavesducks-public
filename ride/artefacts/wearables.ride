{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

func staticKey_oracleAddress() = "static_oracleAddress"
func staticKey_breederAddress() = "static_breederAddress"
func staticKey_itemsAddress() = "static_itemsAddress"
func staticKey_extraFee() = "static_extraFee"
func staticKey_feeAggregator() = "static_feeAggregator"


let wearables = [
  "ART-CAPE", # Magic Cape
  "ART-HAT", # Quacker Hat
  "ART-XSCARF",
  "ART-XSWEATER"
]

func keyArtefactDuck(duckId: String, wearable: String) = duckId+"_"+wearable

func tryGetStringExternal(address: Address, key: String) = {
    match getString(address, key) {
        case a:String => a
        case _ => ""
    }
}


func tryGetString(key: String) = {
    tryGetStringExternal(this,key)
}

func asInt(value: Any) = match value {
  case int: Int => int
  case _ => throw("wrong type, expected: Int")
}

func asString(value: Any) = match value {
  case string: String => string
  case _ => throw("wrong type, expected: String")
}

func getOracle() = Address(tryGetString(staticKey_oracleAddress()).fromBase58String())
func getBreederAddress() =  Address(tryGetStringExternal(getOracle(),staticKey_breederAddress()).fromBase58String()) #base58'3PDVuU45H7Eh5dmtNbnRNRStGwULA7NY6Hb'
func getItemsAddress() =  Address(tryGetStringExternal(getOracle(),staticKey_itemsAddress()).fromBase58String())
func getFeeAggregator() = Address(tryGetStringExternal(getOracle(),staticKey_feeAggregator()).fromBase58String())


func checkAdditionalPayment(payment: AttachedPayment)= {
  if isDefined(payment.assetId) then throw("WCAP: Please attach waves") else
  let feeAmount = getIntegerValue(getOracle(),staticKey_extraFee())
  if payment.amount != feeAmount then throw("WCAP: Please attach exactly "+feeAmount.toString()+" amount of wavelets") else
  [ScriptTransfer(getFeeAggregator(), feeAmount, unit)]

}

func tryGetCosmeticItem(item:String)= {
  let key = "direct_cosmetic_"+item
    match getInteger(getItemsAddress(), key) {
      case a:Int => a
      case _ => unit
    }
}

func wearItem(assetIdWearAble: String, duckId: String)={
  strict artefactName = invoke(getItemsAddress(),"checkArtefactDetails",[assetIdWearAble],[]).asString()
  if !containsElement(wearables, artefactName) && !isDefined(tryGetCosmeticItem(artefactName)) then throw("WRITD: Unsupported wearable") else
    let artefactId = tryGetString(keyArtefactDuck(duckId,artefactName))
    strict boostDuck = if artefactName == "ART-XSCARF" then invoke(getItemsAddress(),"manipulateBoost",[69,duckId],[]) else nil
    if artefactId != "" then throw("Duck is already wearing a "+artefactName) else
      [
        StringEntry(keyArtefactDuck(duckId,artefactName), assetIdWearAble)
      ]
}

@Callable(i)
func configureOracle(oracle: String) = {
  if i.caller != this then throw("admin only") else 
  [
    StringEntry(staticKey_oracleAddress(),oracle)
  ]

}

@Callable(i)
func wearItemToDuck() = {
  let firstPayment = i.payments[0].value()
  let secondPayment = i.payments[1].value()
  let validPayment = checkAdditionalPayment(i.payments[2])
  let duckId = firstPayment.assetId.value().toBase58String()
  let secondAssetId = secondPayment.assetId.value().toBase58String()
  if (firstPayment.amount != 1 || secondPayment.amount != 1) then throw("WRITD: NFT is not attached") else
  strict children = invoke(getBreederAddress(),"validateAndGetChildren",[duckId],[]).asInt()
  wearItem(secondAssetId,duckId)++[
    ScriptTransfer(i.caller, 1, firstPayment.assetId)
  ]++validPayment

}

@Callable(i)
func wearXItemsToDuck()= {
  let validPayment = checkAdditionalPayment(i.payments[1])
  if size(i.payments) < 3 then throw("WWXITD: Please attach at least 1 item and 1 duck!") else 
  if size(i.payments) > 7 then throw("WWXITD: You can only attach 5 items and one duck!") else
    func handleItem(acc: List[StringEntry|ScriptTransfer], payment: AttachedPayment) = {
        let index  = indexOf(i.payments,payment)
        if index ==0 then
          let duckId = payment.assetId.value().toBase58String()
          if (payment.amount != 1 ) then throw("WRITD: Duck is not attached") else
          strict children = invoke(getBreederAddress(),"validateAndGetChildren",[duckId],[]).asInt()
          acc++[
            ScriptTransfer(i.caller, 1, payment.assetId)
          ]
        else
            acc++wearItem(payment.assetId.value().toBase58String(),i.payments[1].assetId.value().toBase58String())

    }
    FOLD<6>(i.payments, [], handleItem)++validPayment
}

#@Callable(i)
#func removeItemFromDuck(artefactName: String)={
#  let firstPayment = i.payments[0].value()
#  let duckId = firstPayment.assetId.value().toBase58String()
#  strict children = invoke(getBreederAddress(),"validateAndGetChildren",[duckId],[]).asInt()
#  let artefactId = tryGetString(keyArtefactDuck(duckId,artefactName))
#  if !isDefined(tryGetCosmeticItem(artefactName)) then throw("WRIFD: Only true cosmetics can be removed!") else
#  if artefactId=="" then throw("WRIFD: this duck does not wear a "+artefactName)else
#  [
#    DeleteEntry(keyArtefactDuck(duckId,artefactName)),
#    ScriptTransfer(i.caller, 1, artefactId.fromBase58String())
#  ]
#}