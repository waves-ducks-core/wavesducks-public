{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
func getBool(key: String) = {
  match getBoolean(this, key) {
      case b:Boolean => b
      case _ => false
  }
}

func isTestEnv()={
  getBool("TESTENV")
}

func staticKey_oracleAddress() = "static_oracleAddress"
func staticKey_ammAddress() = "static_ammAddress"

func getOracle() = Address(getStringValue(this,staticKey_oracleAddress()).fromBase58String())

func getAssetBytes(assetIdStr: String) = {
  if (assetIdStr == "WAVES") then {unit} else {assetIdStr.fromBase58String()}
}


func getTokenBalance(assetId: ByteVector|Unit) = {
  match (assetId) {
      case t:ByteVector => assetBalance(this, t)
      case _ => wavesBalance(this).available
    }
}

func addAssetBytesToList(accum: List[ByteVector], item: String) = { accum ++ [item.getAssetBytes()] }

func convertStringIntoAmm(amm: String) ={
  let amms = getStringValue(getOracle(),staticKey_ammAddress())
  let list = amms.split(",")
  if  containsElement(list, amm) then addressFromString(amm).value() else throw("BCO: AMM not found")
}
@Callable(i)
func generateAndStakeIndex(amm: String) = {
  let mainAddress = convertStringIntoAmm(amm)
  let assetIds = FOLD<10>(getStringValue(mainAddress, "static_tokenIds").split(","), [], addAssetBytesToList)
  let baseAssetId = getStringValue(mainAddress, "static_baseTokenId").getAssetBytes()
  let secondaryAssetIds = assetIds.removeByIndex(assetIds.indexOf(baseAssetId).value())
  let poolIndexId = getBinaryValue(mainAddress, "global_poolToken_id")

  strict PIssuedAmount = match reentrantInvoke(mainAddress, "generateIndex", [true], i.payments) {
    case x: Int => x
    case _ => 0
  }

  strict stakeInvoke = reentrantInvoke(mainAddress, "stakeIndex", [], [AttachedPayment(poolIndexId, PIssuedAmount)])
  []
}

@Callable(i)
func unstakeAndRedeemIndex(amm: String,amount: Int) = {
  let mainAddress = convertStringIntoAmm(amm)
  let assetIds = FOLD<10>(getStringValue(mainAddress, "static_tokenIds").split(","), [], addAssetBytesToList)
  let baseAssetId = getStringValue(mainAddress, "static_baseTokenId").getAssetBytes()
  let secondaryAssetIds = assetIds.removeByIndex(assetIds.indexOf(baseAssetId).value())
  let poolIndexId = getBinaryValue(mainAddress, "global_poolToken_id")
  
  strict unstakeInvoke = reentrantInvoke(mainAddress, "unstakeIndex", [amount], i.payments)
  strict redeemInvoke = reentrantInvoke(mainAddress, "redeemIndex", [true], [AttachedPayment(poolIndexId, amount)])
  []
}

@Callable(i)
func configureOracle(oracle: String) = {
  if i.caller != this then throw("BCO: admin only") else 
  [
    StringEntry(staticKey_oracleAddress(),oracle)
  ]

}

@Verifier(tx)
func verify() = {
  if isTestEnv() then 
      sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
  else
    let firstUser = base58'6TdaXEfhnjYquvPf3yV7MFxt2CbgFmaqsvGwkKfXtKi4'
    let secondUser = base58'7DsP2WaMLocbHuUxux7pbXRjTrrZ1TFQPsi5QumS3gr8'
    let thirdUser = base58'BpFWP3p3JgYrrP45xfrKzeMcWMEXoinj4FVPPkUiA8D3'

    let firstUserSigned = if (sigVerify(tx.bodyBytes, tx.proofs[0], firstUser)) then 1
        else if (sigVerify(tx.bodyBytes, tx.proofs[1], firstUser)) then 1
        else if (sigVerify(tx.bodyBytes, tx.proofs[2], firstUser)) then 1
        else 0
    let secondUserSigned = if (sigVerify(tx.bodyBytes, tx.proofs[0], secondUser)) then 1
        else if (sigVerify(tx.bodyBytes, tx.proofs[1], secondUser)) then 1
        else if (sigVerify(tx.bodyBytes, tx.proofs[2], secondUser)) then 1
        else 0
    let thirdUserSigned = if (sigVerify(tx.bodyBytes, tx.proofs[0], thirdUser)) then 1
        else if (sigVerify(tx.bodyBytes, tx.proofs[1], thirdUser)) then 1
        else if (sigVerify(tx.bodyBytes, tx.proofs[2], thirdUser)) then 1
        else 0
    let signaturesCount = firstUserSigned + secondUserSigned + thirdUserSigned

    match (tx) {
        case _ => signaturesCount >= 2
    }
} 

